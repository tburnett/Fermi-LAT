"""
"""

import os, sys, glob
import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt 
from utilities import SkyDir, healpix, FluxTable

from jupydoc import DocPublisher

__docs__= ['PSCstudy']

class PSCstudy(DocPublisher):
    """
    title: Study the Catalog diffuse parameters

    author: Toby Burnett
    
    sections: introduction plots [ plot_version.3FGL plot_version.4FGL-DR2 plot_version.4FGL-DR2-UW  ]
        summary

    diffuse_files: 
        - 'gll_iem_v07x_hpx.fits'
        -  'isotropic_8years_P305_SOURCE_FRONT_XC04_interp2.txt'
    
    
    psc_files:
        3FGL: gll_psc_v16.fit
        4FGL: gll_pscP305uw8606_v6.fit
        4FGL-DR2: gll_pscP305uw9011_v12r2_assoc_v8r4p1_classes.fits
        4FGL-DR2-UW: gll_pscP305uw9011_v16.fit

    diffuse_path: $FERMI/diffuse

    uw_diffuse: $FERMI/diffuse/uw/gll_iem_uw_v3.fits

    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.diffuse_path = os.path.expandvars(self.diffuse_path)
        self.gflux = healpix.HPcube.from_FITS(os.path.join(self.diffuse_path, self.diffuse_files[0]))
        self.isoflux = FluxTable(os.path.join(self.diffuse_path,self.diffuse_files[1]))
        plt.rc('font', size=14)


    def roi_dataframe(self, f):
        from astropy.io import fits
        from astropy.table import Table

        print( 'opening file psc "{}"'.format(f))
        df=Table.read(f, hdu='ROIS').to_pandas()
        df['singlat'] = np.sin(np.radians(df.GLAT))

        glon =df.GLON.copy()
        glon[glon>180] -=360
        # position and size
        df['glat']=df.GLAT
        df['glon']=glon
        df['ra']=df.RAJ2000
        df['dec']=df.DEJ2000
        df['radius'] = df.get('CoreRadius, 0')

        # fit parameters
        df['gal_norm']=df.PARNAM1
        df['gal_index']=df.PARNAM2
        df['iso_norm']=df.PARNAM3

        # ratio of galactic to isotropic flux, at 1 GeV
        sd = SkyDir(df.ra.values, df.dec.values)  
        df['flux_ratio'] = self.gflux(sd, 1000) / self.isoflux(1000)


        return df['glon glat ra dec radius gal_norm gal_index iso_norm flux_ratio'.split()]

    def introduction(self):
        """Introduction

        This is a study of the diffuse fit parameters used by the 3FGL and 4FGL catalogs to assess the validity of the galactic diffuse model used. 
        To the extent that the model is a valid descrition of the data (including of course an assumed set of source parameters), 
        the various corrections should be small.
        """
        #----------
        self.publishme()

    def galactic_maps(self):
        """Galactic Diffuse Model

        The diffuse model used by 4FGL is `{self.diffuse_files[0]}`. It includes a data-based measurement of the Loop I structure and Fermi bubbles using its "patch". It tends to have small-angle structure. This fact, and the limited extent is emphasized by the extrapolation to 1 TeV:
        {fig1}

        For comparison, here is the UW model:

        {fig2}

        ###A concern:
        Should we trust a model with such unrealistic structure?
        """
        fig1 = plt.figure(figsize=(12,6), num=1)
        self.gflux.ait_plot(1e6, fig=fig1 )
        fig1.caption = f'Flux from {self.diffuse_files[0]} at 1 TeV.'
        
        fig2 = plt.figure(figsize=(12,6), num=2)
        uwdiffuse = healpix.HPcube.from_FITS(os.path.expandvars(self.uw_diffuse) )
        uwdiffuse.ait_plot(1e6, fig=fig2 ,label='')
        fig2.caption = f'Flux from UW diffuse model at 1 TeV.'

        #---------
        self.publishme()

    def plot_version(self, version):
        """ Catalog {version}

        {summary}

        File: `{filename}`
        #### Global
        <table>
         <tr>  <td>{fig1}</td>       <td>{fig2}</td>    </tr>
        </table>
         
        #### Stripes 
        <table>
         <tr>  <td>{fig3}</td>       <td>{fig4}</td>    </tr>
        </table>

        """
        print(f'Version: {version}, ', end='')

        summary={
            '3FGL':      "The 3FGL catalog, using the diffuse model generated by Jean-Marc ",
            '4FGL-DR2':  "The 10-year 4FGL catalog, 4FGL-DR2",
            '4FGL-DR2-UW':"A test run of 4FGL-DR2 using the UW v3 diffuse model.",
            }[version]

        filename = self.psc_files[version]
        psc_file = os.path.expandvars(os.path.join('$FERMI/catalog', filename))
        #print(psc_file)
        assert os.path.exists(psc_file), f'Not found: {psc_file}'
       
        df = self.roi_dataframe(psc_file)        

        dm = DiffuseMaps(df, self.gflux, self.isoflux)
        self.dm[version] = dm

        fig1 = dm.ait_plot( fignum=1 )
        fig1.caption=f'Diffuse normalization factor at 1 GeV.'

        fig2 = dm.hist(fignum=2)
        fig2.caption=f'Total diffuse factor: red is weighted by flux.'

        fig3 = self.figure(dm.stripe('Polar', fignum=3), width=500)
        fig4 = self.figure(dm.stripe('Planar',fignum=4), width=500)
        #--------------

        self.publishme()

    def plots(self):
        """ROI parameter distributions

        This is a look at the ROIs and their diffuse fit parameters, for the catalog versions 3FGL, 4FGL, 4FGL-DR2, and a special run of 4FGL-DR2 using the Uw diffuse model.        
               
        These represent a measurement, using a consistent set of point- and extended sources, of corrections to the 
        galactic diffuse model assumed.
        
        Each subsection has a set of plots, described here:

        #### Global maps
        Here we make a map of the diffuse, galactic+isotropic, normalization factor at 1 GeV, for each pixel of an nside=128 map, using the nearest ROI.
        This is the *relative* change of the diffuse prediction, based on the galactic and isotropic normalization factors, using the galactic flux at the center.

        #### Parameter values along stripes through the GC.
        The most difficult regions are along the galactic plane, and the meridian that passes
        through the bubbles and Loop I. The latter features are not part of the galactic model, but were presumably accounted for by the "patch" component 
        derived using data.  

    
        The shaded areas show the coverage of the patch used for the 4FGL map. 


        """
        # patch_image = self.image(
        #     os.path.join(os.path.expandvars(self.diffuse_path),'XC04-patch.png'), 
        #     caption='Diffuse model id "XC04" patch component: counts for the 228 MeV band used to generate the model.', 
        #     width=600)

        self.dm = {}

        self.publishme()

    def summary(self):
        r"""Summary

        Based on the count normalization adjustment at 1 GeV, the UW v3 model, applied to the 10-year
        data, is best, with 3FGL second. 

        The RMS values, in percent, for the combined diffuse normalization factors at 1 GeV for the three catalogs:

        {summary_table}
        
        
        ### Comparison with UW analysis

        These results can be compared with the equivalents from the 10- and 12-year UW models, {model_ref} respectively.
        Those fits are performed independently for each of the 8 energy bands, with fixed isotropic. So eight parameters
        rather than three. 
        
        First the plots from the respective reports:

        <table>
         <tr>  <td>{plot1}</td>       <td>{plot2}</td>    </tr>
        </table>

        The equivalent AIT plots, also with $\pm10\%$ scale

        {plot3}
        {plot4}

        The UW 10-year model used for 4FGL-DR2 had a galactic diffuse which worked extremely well. 
        But it exists only in a convolved, count-map form. 
        
        The 12-year model uses the result of an attempt to generate a differential flux form.
        It is not as successful, but certainly is an improvement over the current version. A difference is that
        it applied the patch adjustment for energies above 10 GeV using a log-parabola fit to the 100 MeV- 10 GeV 
        range. 
     
        """
        with self.capture_print() as summary_table:
            for key in '3FGL 4FGL-DR2 4FGL-DR2-UW'.split():
                cmap = self.dm[key].cmap.map
                print(f'{key:15s}{cmap.std()*100:.1f}%')

        uwmodels = 'uw9011 uw1210'.split()
        
        plots=[]
        for model in uwmodels:
            fn = f'/tmp/skymodels/{model}/plots/environment/galactic_correction_maps_{model}.jpg'
            plots.append( self.image(fn, width=500, caption=f'Galactic diffuse normalizations for {model}.'))
        plot1, plot2 = plots

        # get figures from another doc
        doc_path = os.path.split(self.doc_folders[0])[0]
        docs = []
        for model in uwmodels:
            doc = os.path.join(doc_path, f'ResidualAnalysis.{model}')
            docs.append(f'../ResidualAnalysis.{model}/index.html?skipDecoration')
            image_file = os.path.join(doc, 'figs', 'fig_01.png')
            im = self.image(image_file, caption=f'Normalization factors from model {model}')
            plots.append(im)    
        plot3, plot4= plots[2:]  

        doc_href = lambda model: f'../ResidualAnalysis.{model}/index.html?skipDecoration'
        model_ref = ' and '.join( [f'<a href="{doc_href(model)}">{model}</a>' for model in uwmodels ])



        self.publishme()

class DiffuseMaps(object):
    
    def __init__(self, 
                df:'DataFrame with parameters', 
                gflux:'HPcube with galactic flux',
                isoflux:'FluxTable object',
                nside=128):
        
        self.df = df
        self.gflux = gflux
        self.isoflux = isoflux
        
        # construct count normalization  
        r =df.flux_ratio
        df.loc[:,'cnt_norm'] = (df.gal_norm*r + df.iso_norm) / (1+r)
       
        # make a catalog, and index of closest energy for all-sky list
        roidirs = SkyDir.gal(df.glon, df.glat)        
        allskydirs = SkyDir.from_healpix(range(12*nside**2),nside)
        idx, _ = allskydirs.match(roidirs)



        cnt_norm = df.iloc[idx].cnt_norm
        self.cmap = healpix.HPmap(cnt_norm.values)
                
    
    def stripe(self, label='Polar', fignum=2, energy=1000):
        df = self.df
           
        if label == 'Polar':
            cosb = np.cos( np.radians(df.glat) )
            stripe = np.abs(df.glon)<5/cosb
            blist = np.linspace(-90,90,180)
            x = df.glat[stripe]
            span = dict(xmin=-75, xmax=85, color='orange',alpha=0.1)
            xlim = (-90,90)
            xlabel = r'$b\ \mathrm{[deg]}$'
            xticks = np.linspace(-90,90,13)
            title = r'$\mathrm{{{{  {}\ Stripe: {}\ ROIs\  with}}}}\ |l|<5/ \cos(b)$'.format(
                label,sum(stripe))
        elif label=='Planar':
            stripe = np.abs(df.glat)<2
            x = df.glon[stripe]
            y = df.glat[stripe]
            xlim = (180,-180)
            xlabel = r'$l\ \mathrm{[deg]}$'
            xticks = np.linspace(180,-180,13)
            span = dict(xmin=-90, xmax=165, color='orange',alpha=0.1)
            title = r'$\mathrm{{{{ {}\ Stripe: {}\ ROIs\  with}}}}\ |b|<2 $'.format(
                label,sum(stripe))
        
        iflux1000 = self.isoflux( 1000.)
        
        fig,axx = plt.subplots(4,1, figsize=(10,10), sharex=True, num=fignum,
                            gridspec_kw=dict(top=0.92, left=0.15, hspace=0.05))
        
        for i,ax in enumerate(axx):
            ax.grid(alpha=0.5)
            ax.axvline(0, color='grey')
            if i>0: 
                ax.axhline(1.0, color='grey');
                ax.axvspan(**span)
            if i==0:# flux 
                y = self.gflux(SkyDir.gal(df.glon[stripe], df.glat[stripe]), energy)
                ax.semilogy(x, y, '+', label='galactic')
                # fix this later
                ax.axhline(iflux1000, color='g', ls='--', label='isotropic')
                ax.legend()
                ax.set( ylabel=f'Flux @ {energy*1e-3:.0f} GeV')
            elif i==1: #galactic norm
                ax.plot( x, df.gal_norm[stripe].clip(0.8,1.2), 'o');
                ax.set( ylabel='gal norm', ylim=(0.8,1.2));
            elif i==2: #galactic index
                ax.plot( x, df.gal_index[stripe], 'o');
                ax.axhline(0, color='grey')
                ax.set( ylabel='gal index', ylim=(-0.15,0.15))#, ylim=(0.5,1.1));
            elif i==3: #iso norm
                ax.plot(x, df.iso_norm[stripe].clip(0,2),'o');
                ax.set( ylabel='iso norm', ylim=(0., 2.02), 
                xlim=xlim, xlabel=xlabel, xticks=xticks)
        fig.caption = title   
        fig.text( 0.01, 0.4, 'Diffuse parameters', va='center', rotation='vertical')
        fig.set_facecolor('white')
        return fig

    def ait_plot(self, fig=None, nside=128, **aitkw):
        
        ait = dict( vmin=0.9,vmax=1.1)
        ait.update(aitkw)
        self.cmap.ait_plot(fig=fig, **ait)
        return plt.gcf()

    def hist(self, fignum=1):
        
        m = self.cmap.map; nside=128
        allskydirs = SkyDir.from_healpix(range(12*nside**2),nside)
        w = self.gflux(allskydirs, 1e3)
        
        fig, ax = plt.subplots(figsize=(5,4), num=fignum)
        hkw = dict(bins=np.linspace(0.75,1.25, 51), density=True, histtype='step', lw=2, log=False)
        ax.hist(m, **hkw)
        ax.hist(m, weights=w,  color='red', **hkw)
        ax.grid(alpha=0.5)
        ax.set( xlabel='Diffuse Count factor')
        ax.text(0.6,0.85, f'mean {m.mean():.3f}\nstd    {m.std():.3f}',
            color='blue', transform=ax.transAxes )
        
        mw_mean = np.sum(m*w)/np.sum(w)
        mw_std  = np.sqrt(np.sum(m**2*w)/np.sum(w) - mw_mean**2)
        ax.text(0.6,0.65, f'mean {mw_mean:.3f}\nstd    {mw_std:.3f}',
            color='red', transform=ax.transAxes )
        return fig
