"""
"""

import os, sys, glob
import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt 
from utilities import SkyDir, healpix

from jupydoc import DocPublisher

__docs__= ['PSCstudy']

class PSCstudy(DocPublisher):
    """
    title: Study the Catalog diffuse parameters

    author: Toby Burnett
    
    sections: introduction plots [ plot_version.4FGL-DR2 plot_version.4FGL-DR2-UW  plot_version.3FGL ]
        summary

    diffuse_files: 
        - 'gll_iem_v07x_hpx.fits'
        - 'isotropic_8years_P305_SOURCE_FRONT.txt'
    
    
    psc_files:
        3FGL: gll_psc_v16.fit
        4FGL: gll_pscP305uw8606_v6.fit
        4FGL-DR2: gll_pscP305uw9011_v12r2_assoc_v8r4p1_classes.fits
        4FGL-DR2-UW: gll_pscP305uw9011_v16.fit

    diffuse_path: $FERMI/diffuse

    uw_diffuse: $FERMI/diffuse/uw/gll_iem_uw_v3.fits

    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.diffuse_path = os.path.expandvars(self.diffuse_path)
        self.gflux = healpix.HPcube.from_FITS(os.path.join(self.diffuse_path, self.diffuse_files[0]))
        plt.rc('font', size=14)


    def roi_dataframe(self, f):
        from astropy.io import fits
        from astropy.table import Table

        print( 'opening file psc "{}"'.format(f))
        df=Table.read(f, hdu='ROIS').to_pandas()
        df['singlat'] = np.sin(np.radians(df.GLAT))

        glon =df.GLON.copy()
        glon[glon>180] -=360
        df['glat']=df.GLAT
        df['glon']=glon
        df['ra']=df.RAJ2000
        df['dec']=df.DEJ2000
        # df['radius'] = df.CoreRadius
        df['radius'] = 0
        df['gal_norm']=df.PARNAM1
        df['gal_index']=df.PARNAM2
        df['iso_norm']=df.PARNAM3

        return df['glon glat ra dec radius gal_norm gal_index iso_norm '.split()]

    def introduction(self):
        """Introduction

        This is a study of the diffuse fit parameters used by the 3FGL and 4FGL catalogs to assess the validity of the galactic diffuse model used. 
        To the extent that the model is a valid descrition of the data (including of course an assumed set of source parameters), 
        the various corrections should be small.
        """
        #----------
        self.publishme()

    def galactic_maps(self):
        """Galactic Diffuse Model

        The diffuse model used by 4FGL is `{self.diffuse_files[0]}`. It includes a data-based measurement of the Loop I structure and Fermi bubbles using its "patch". It tends to have small-angle structure. This fact, and the limited extent is emphasized by the extrapolation to 1 TeV:
        {fig1}

        For comparison, here is the UW model:

        {fig2}

        ###A concern:
        Should we trust a model with such unrealistic structure?
        """
        fig1 = plt.figure(figsize=(12,6), num=1)
        self.gflux.ait_plot(1e6, fig=fig1 )
        fig1.caption = f'Flux from {self.diffuse_files[0]} at 1 TeV.'
        
        fig2 = plt.figure(figsize=(12,6), num=2)
        uwdiffuse = healpix.HPcube.from_FITS(os.path.expandvars(self.uw_diffuse) )
        uwdiffuse.ait_plot(1e6, fig=fig2 ,label='')
        fig2.caption = f'Flux from UW diffuse model at 1 TeV.'

        #---------
        self.publishme()

    def plot_version(self, version):
        """ Catalog {version}

        {summary}

        File: `{filename}`
        #### Global
        <table>
         <tr>  <td>{fig1}</td>       <td>{fig2}</td>    </tr>
        </table>
         
        #### Stripes 
        <table>
         <tr>  <td>{fig3}</td>       <td>{fig4}</td>    </tr>
        </table>

        """
        print(f'Version {version}')

        if version=='4FGL-DR2':
            summary="""The 10-year 4FGL catalog, 4FGL-DR2
            """
        elif version=='4FGL-DR2-UW':
            summary="""A test run of 4FGL-DR2 using the UW v3 diffuse model.
            """
        elif version=='3FGL':
            summary="""The 3FGL catalog, using the diffuse model generated by Jean-Marc
            """
        else:     summary='?'

        filename = self.psc_files[version]
        psc_file = os.path.expandvars(os.path.join('$FERMI/catalog', filename))
        #print(psc_file)
        assert os.path.exists(psc_file), f'Not found: {psc_file}'
       
        df = self.roi_dataframe(psc_file)        

        dm = DiffuseMaps(df, self.gflux)
        self.dm[version] = dm

        fig1 = dm.ait_plot( fignum=1 )
        fig1.caption=f'Galactic normalization factor at 1 GeV.'

        fig2 = dm.hist(fignum=2)
        fig2.caption=f'Distribution of factors: red is weighted by flux.'

        fig3 = self.figure(dm.stripe('Polar', fignum=3), width=500)
        fig4 = self.figure(dm.stripe('Planar',fignum=4), width=500)
        #--------------

        self.publishme()

    def plots(self):
        """ROI parameter distributions

        This is a look at the ROIs and their diffuse fit parameters, for the catalog versions 3FGL, 4FGL, 4FGL-DR2, and a special run of 4FGL-DR2 using the Uw diffuse model.
        
               
        These represent a measurement, using a consistent set of point- and extended sources, of corrections to the 
        galactic diffuse model assumed.
        
        Each subsection has a set of plots, described here:

        #### Global maps
        Here we make a map of the Galactic normalization coefficient, which applies to 1 GeV, for each pixel of an nside=128 map, using the nearest ROI.
        This is of course the *relative* change. 

        #### Parameter values along stripes through the GC.
        The most difficult regions are along the galactic plane, and the meridian that passes
        through the bubbles and Loop I. The latter features are not part of the galactic model, but were presumably accounted for by the "patch" component 
        derived using data.  

    
        The shaded areas show the coverage of the patch used for the 4FGL map. 


        """
        # patch_image = self.image(
        #     os.path.join(os.path.expandvars(self.diffuse_path),'XC04-patch.png'), 
        #     caption='Diffuse model id "XC04" patch component: counts for the 228 MeV band used to generate the model.', 
        #     width=600)

        self.dm = {}

        self.publishme()

    def summary(self):
        r"""Summary

        Based on the global Galactic adjustment at 1 GeV, 3FGL is clearly the best. The UW v3 model, applied to the 10-year
        data, is better by this measure, but not dramatically so. 

        This is to be compared with the equivalents from the 10- and 12-year UW models, {models} respectively.
        
        <table>
         <tr>  <td>{plot1}</td>       <td>{plot2}</td>    </tr>
        </table>


        The equivalent AIT plots. Note the $\pm10\%$ scale

        {plot3}
        {plot4}

        These are from the <a href="{doc1}">uw9011</a> and <a href="{doc2}">uw1210</a> residual analysis documents.

        The UW 10-year model used for 4FGL-DR2 had a galactic diffuse which worked extremely well. 
        This only exists in a convolved, count-map form. The attempt to generate a differential flux form was not as 
        successful, but certainly is an improvement over the current version.

        It is a mystery why the UW and SACLAY diffuse fits differ by so much at high latitudes&mdash;fits to point sources are mostly quite consistent. If this could be resolved, the UW model would be much better.    

        """
        models = 'uw9011 uw1210'
        plots=[]
        for model in models.split():
            fn = f'/tmp/skymodels/{model}/plots/environment/galactic_correction_maps_{model}.jpg'
            plots.append( self.image(fn, width=500, caption=f'Galactic diffuse normalizations for {model}.'))
        plot1, plot2 = plots

        # get figures from another doc
        path = os.path.split(self.doc_folders[0])[0]
        docs = []
        for model in models.split():
            doc = os.path.join(path, f'ResidualAnalysis.{model}')
            docs.append(f'../ResidualAnalysis.{model}/index.html?skipDecoration')
            image_file = os.path.join(doc, 'figs', 'fig_01.png')
            im = self.image(image_file, caption=f'Normalization factors from model {model}')
            plots.append(im)    
        plot3, plot4= plots[2:]  
        doc1, doc2 = docs 

        self.publishme()

class DiffuseMaps(object):
    
    def __init__(self, 
                df:'DataFrame with parameters', 
                gflux:'HPcube with galactic flux',
                nside=128):
        
        self.df = df
        self.gflux = gflux
       
        # make a catalog, and index of closest energy for all-sky list
        roidirs = SkyDir.gal(df.glon, df.glat)        
        allskydirs = SkyDir.from_healpix(range(12*nside**2),nside)
        idx, _ = allskydirs.match(roidirs)

        gal_norm = df.iloc[idx].gal_norm
        self.gmap = healpix.HPmap(gal_norm.values)
    
    def stripe(self, label='Polar', fignum=2, energy=1000):
        df = self.df
           
        if label == 'Polar':
            cosb = np.cos( np.radians(df.glat) )
            stripe = np.abs(df.glon)<5/cosb
            blist = np.linspace(-90,90,180)
            x = df.glat[stripe]
            span = dict(xmin=-75, xmax=85, color='orange',alpha=0.1)
            xlim = (-90,90)
            xlabel = r'$b\ \mathrm{[deg]}$'
            xticks = np.linspace(-90,90,13)
            title = r'$\mathrm{{{{  {}\ Stripe: {}\ ROIs\  with}}}}\ |l|<5/ \cos(b)$'.format(
                label,sum(stripe))
        elif label=='Planar':
            stripe = np.abs(df.glat)<2
            x = df.glon[stripe]
            y = df.glat[stripe]
            xlim = (180,-180)
            xlabel = r'$l\ \mathrm{[deg]}$'
            xticks = np.linspace(180,-180,13)
            span = dict(xmin=-90, xmax=165, color='orange',alpha=0.1)
            title = r'$\mathrm{{{{ {}\ Stripe: {}\ ROIs\  with}}}}\ |b|<2 $'.format(
                label,sum(stripe))
        
        # iflux1000 = iso_spect(0, 1000.)
        
        fig,axx = plt.subplots(4,1, figsize=(10,12), sharex=True, num=fignum,
                            gridspec_kw=dict(top=0.92, left=0.15, hspace=0.05))
        
        for i,ax in enumerate(axx):
            ax.grid(alpha=0.5)
            ax.axvline(0, color='grey')
            if i>0: 
                ax.axhline(1.0, color='grey');
                ax.axvspan(**span)
            if i==0:# flux 
                y = self.gflux(SkyDir.gal(df.glon[stripe], df.glat[stripe]), energy)
                ax.semilogy(x, y, '+', label='galactic')
                # fix this later
                #ax.axhline(iflux1000, color='g', ls='--', label='isotropic')
                ax.legend()
                ax.set( ylabel=f'Flux @ {energy*1e-3:.0f} GeV')
            elif i==1: #galactic norm
                ax.plot( x, df.gal_norm[stripe].clip(0.8,1.2), 'o');
                ax.set( ylabel='gal norm', ylim=(0.8,1.2));
            elif i==2: #galactic index
                ax.plot( x, df.gal_index[stripe], 'o');
                ax.axhline(0, color='grey')
                ax.set( ylabel='gal index', ylim=(-0.15,0.15))#, ylim=(0.5,1.1));
            elif i==3: #iso norm
                ax.plot(x, df.iso_norm[stripe].clip(0,2),'o');
                ax.set( ylabel='iso norm', ylim=(0., 2.02), 
                xlim=xlim, xlabel=xlabel, xticks=xticks)
        fig.caption = title   
        fig.text( 0.01, 0.4, 'Diffuse parameters', va='center', rotation='vertical')
        return fig

    def ait_plot(self, fig=None, nside=128, **aitkw):
        
        ait = dict( vmin=0.7,vmax=1.3)
        ait.update(aitkw)
        self.gmap.ait_plot(fig=fig, **ait)
        return plt.gcf()

    def hist(self, fignum=1):
        
        m = self.gmap.map; nside=128
        allskydirs = SkyDir.from_healpix(range(12*nside**2),nside)
        w = self.gflux(allskydirs, 1e3)
        
        fig, ax = plt.subplots(figsize=(5,4), num=fignum)
        hkw = dict(bins=np.linspace(0.75,1.25, 51), density=True, histtype='step', lw=2, log=False)
        ax.hist(m, **hkw)
        ax.hist(m, weights=w,  color='red', **hkw)
        ax.grid(alpha=0.5)
        #ax.set(ylim=(10,None), xlabel='Galactic correction')
        ax.text(0.6,0.85, f'mean {m.mean():.3f}\nstd    {m.std():.3f}',
            color='blue', transform=ax.transAxes )
        
        mw_mean = np.sum(m*w)/np.sum(w)
        mw_std  = np.sqrt(np.sum(m**2*w)/np.sum(w) - mw_mean**2)
        ax.text(0.6,0.65, f'mean {mw_mean:.3f}\nstd    {mw_std:.3f}',
            color='red', transform=ax.transAxes )
        return fig
